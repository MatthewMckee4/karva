{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Karva (0.1.6)","text":"<p>A Python test framework, written in Rust.</p>"},{"location":"cli/","title":"CLI","text":""},{"location":"cli/#cli-reference","title":"CLI Reference","text":""},{"location":"cli/#karva","title":"karva","text":"<p>A Python test runner.</p> Usage <pre><code>karva &lt;COMMAND&gt;\n</code></pre> Commands <code>karva test</code><p>Run tests</p> <code>karva version</code><p>Display Karva's version</p> <code>karva help</code><p>Print this message or the help of the given subcommand(s)</p>"},{"location":"cli/#karva-test","title":"karva test","text":"<p>Run tests</p> Usage <pre><code>karva test [OPTIONS] [PATH]...\n</code></pre> Arguments <code>PATHS</code><p>List of files, directories, or test functions to test [default: the project root]</p> Options <code>--help</code>, <code>-h</code><p>Print help</p> <code>--no-ignore</code><p>When set, .gitignore files will not be respected.</p> <code>--show-output</code>, <code>-s</code><p>Show Python stdout during test execution</p> <code>--test-prefix</code> test-prefix<p>The prefix of the test functions</p> <p>[default: test]</p><code>--verbose</code>, <code>-v</code><p>Use verbose output (or <code>-vv</code> and <code>-vvv</code> for more verbose output)</p>"},{"location":"cli/#karva-version","title":"karva version","text":"<p>Display Karva's version</p> Usage <pre><code>karva version\n</code></pre> Options <code>--help</code>, <code>-h</code><p>Print help</p>"},{"location":"cli/#karva-help","title":"karva help","text":"<p>Print this message or the help of the given subcommand(s)</p> Usage <pre><code>karva help [COMMAND]\n</code></pre>"},{"location":"fixtures/","title":"Fixtures","text":""},{"location":"fixtures/#constraints","title":"Constraints","text":"<p>We only discover package level fixtures from a <code>conftest.py</code> file in the root of that package.</p>"},{"location":"fixtures/#fixture-types","title":"Fixture Types","text":"<p>Karva supports different types of fixtures based on their scope:</p>"},{"location":"fixtures/#function-scope","title":"Function Scope","text":"<p>The default scope. The fixture is created for each test function.</p>"},{"location":"fixtures/#module-scope","title":"Module Scope","text":"<p>The fixture is created once per test module.</p>"},{"location":"fixtures/#package-scope","title":"Package Scope","text":"<p>The fixture is created once per test package.</p> <p>This means that every package that is a sub-package of the package with the fixture will create the fixture if and only if it has a module that requires the fixture.</p> <p>For example, if we have the following structure:</p> <pre><code>calculator\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 conftest.py\n    \u251c\u2500\u2500 bar\n    \u2502   \u2514\u2500\u2500 test_bar.py\n    \u2514\u2500\u2500 foo\n        \u2514\u2500\u2500 test_foo.py\n</code></pre> <p>If we have the following fixture in <code>tests/conftest.py</code>:</p> <pre><code>@fixture(scope=\"package\")\ndef package_fixture():\n    return \"package\"\n</code></pre> <p>And if the fixtures is used in <code>tests/foo/test_foo.py</code> and <code>tests/bar/test_bar.py</code> then fixture will be created once for the <code>foo</code> package and once for the <code>bar</code> package.</p> <p>If you wanted it to only create the fixture once you should use the <code>session</code> scope.</p>"},{"location":"fixtures/#session-scope","title":"Session Scope","text":"<p>The fixture is created once per test session.</p>"},{"location":"fixtures/#dynamic-scope","title":"Dynamic Scope","text":"<p>A dynamic scope is given as a function that returns a valid scope string.</p> <pre><code>def dynamic_scope(fixture_name, config):\n    return \"module\"\n</code></pre> <p>Currently, we do not support config and that value is passed as <code>None</code>. The <code>fixture_name</code> argument is a string.</p>"},{"location":"fixtures/#dependent-fixtures","title":"Dependent fixtures","text":"<p>We support fixtures that depend on other fixtures.</p> <pre><code>from karva import fixture\n\n@fixture\ndef function_fixture():\n    return \"function\"\n\n@fixture\ndef dependent_fixture(function_fixture: str) -&gt; str:\n    return function_fixture + \"dependent\"\n\ndef test_dependent(dependent_fixture: str):\n    assert dependent_fixture == \"functiondependent\"\n</code></pre>"},{"location":"fixtures/#finalizers","title":"Finalizers","text":"<p>We support finalizers. These are called after the scope of the fixture has finished running.</p> <pre><code>from karva import fixture\n\n@fixture\ndef finalizer_fixture():\n    print(\"Finalizer fixture initialized\")\n    yield 1\n    print(\"Finalizer fixture finalizer called\")\n\ndef test_finalizer(finalizer_fixture: int):\n    assert finalizer_fixture == 1\n</code></pre>"},{"location":"fixtures/#auto-use-fixtures","title":"Auto-use fixtures","text":"<p>We support auto-use fixtures. These are fixtures that are automatically used in their scope.</p> <pre><code>from karva import fixture\n\ndata = {}\n\n@fixture(auto_use=True)\ndef add_data():\n    data.update(value=True)\n\ndef test_value():\n    assert data.get('value')\n</code></pre>"},{"location":"fixtures/#other-ways-to-use-fixtures","title":"Other ways to use fixtures","text":"<p>Seen here in pytest.</p> <p>You can wrap your test function with a decorator specifying what fixtures you would like to call before running the function.</p> <p>This is technically a tag, but we reference it here has it refers to fixtures.</p> <pre><code>import karva\n\n@karva.fixture\ndef x():\n    # Do something\n    return ...\n\n@karva.fixture\ndef y():\n    # Do something\n    yield ...\n    # Do something else\n\n@karva.tags.use_fixtures(\"x\", \"y\")\ndef test():\n    # Do something\n</code></pre>"},{"location":"fixtures/#overriding-fixtures","title":"Overriding fixtures","text":"<p>We can override fixtures by giving them the same name. When overriding them we can also use them as arguments.</p> <p>conftest.py</p> <pre><code>import pytest\n\n@pytest.fixture\ndef username():\n    return 'username'\n</code></pre> <p>test_something.py</p> <pre><code>def test_username(username):\n    assert username == 'username'\n</code></pre> <p>subfolder/conftest.py</p> <pre><code>import pytest\n\n@pytest.fixture\ndef username(username):\n    return 'overridden-' + username\n</code></pre> <p>subfolder/test_something_else.py</p> <pre><code>def test_username(username):\n    assert username == 'overridden-username'\n</code></pre>"},{"location":"fixtures/#example","title":"Example","text":"<pre><code>uv init --lib calculator\n</code></pre> <p>This will give us a project that looks like this:</p> <pre><code>calculator\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 calculator\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 py.typed\n</code></pre> <p>We can then create our core logic in <code>src/calculator/__init__.py</code>.</p> <pre><code>class Calculator:\n    def add(self, a: int, b: int) -&gt; int:\n        return a + b\n</code></pre> <p>We can then create our fixtures in <code>tests/conftest.py</code>.</p> <pre><code>from karva import fixture\n\n@fixture\ndef calculator() -&gt; Calculator:\n    return Calculator()\n</code></pre> <p>We can then create our tests in <code>tests/test_add.py</code>.</p> <pre><code>from calculator import Calculator\n\ndef test_add(calculator: Calculator):\n    assert calculator.add(1, 2) == 3\n</code></pre> <p>Then, we'll add karva to our project.</p> <pre><code>uv add --dev karva\n</code></pre> <p>We can then run our tests with <code>uv run karva test</code>.</p> <pre><code>uv run karva test\n</code></pre> <p>This will give us a report of our tests.</p> <pre><code>All checks passed!\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Karva is available as <code>karva</code> on PyPI.</p> <p>Use karva directly with <code>uvx</code>:</p> <pre><code>uvx karva test\nuvx karva version\n</code></pre> <p>Or install karva with <code>uv</code>, or <code>pip</code>:</p> <pre><code># With uv.\nuv tool install karva@latest\n\n# Add karva to your project.\nuv add --dev karva\n\n# With pip.\npip install karva\n</code></pre> <p>Once installed, you can use karva to run your tests:</p> <pre><code>karva test\n</code></pre> <p>Or to get the version of karva you're using:</p> <pre><code>karva version\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial will walk you through the basics of using Karva.</p>"},{"location":"tutorial/#getting-started","title":"Getting started","text":"<p>We will first create a new project using <code>uv</code>.</p> <pre><code>uv init --lib calculator\n</code></pre> <p>This will give us a project that looks like this:</p> <pre><code>calculator\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 calculator\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 py.typed\n</code></pre> <p>We can then create our core logic in <code>src/calculator/__init__.py</code>.</p> <pre><code>class Calculator:\n    def add(self, a: int, b: int) -&gt; int:\n        return a + b\n</code></pre> <p>We can then create our tests in <code>tests/test_add.py</code>.</p> <pre><code>from calculator import Calculator\n\ndef test_add():\n    calculator = Calculator()\n    assert calculator.add(1, 2) == 3\n</code></pre> <p>Then, we'll add karva to our project.</p> <pre><code>uv add --dev karva\n</code></pre> <p>We can then run our tests with <code>uv run karva test</code>.</p> <pre><code>uv run karva test\n</code></pre> <p>This will give us a report of our tests.</p> <pre><code>All checks passed!\n</code></pre>"},{"location":"tags/parametrize/","title":"Parametrize","text":"<p>This works like pytest's <code>parametrize</code> decorator.</p> <p>Note</p> <p>When mixing fixtures and parametrize, the parametrize values take priority.</p> <p>First, here is a small example:</p> <pre><code>import karva\n\n@karva.tags.parametrize(\"a\", [1, 2, 3])\ndef test_function(a: int):\n    assert a &gt; 0\n</code></pre> <p>Then running <code>uv run karva test -v</code> will provide the following output:</p> <pre><code>INFO Discovering tests...\nINFO Discovered 1 test in 1 file\nINFO running  | test_parametrize::test_function [1]\nINFO passed   | test_parametrize::test_function [1]\nINFO running  | test_parametrize::test_function [2]\nINFO passed   | test_parametrize::test_function [2]\nINFO running  | test_parametrize::test_function [3]\nINFO passed   | test_parametrize::test_function [3]\nPassed tests: 3\nAll checks passed!\n</code></pre> <p>We can also parametrize multiple arguments:</p> <pre><code>import karva\n\n@karva.tags.parametrize((\"a\", \"b\"), [(1, 4), (2, 5), (3, 6)])\ndef test_function(a: int, b: int):\n    assert a &gt; 0 and b &gt; 0\n</code></pre> <p>Then running <code>uv run karva test -v</code> will provide the following output:</p> <pre><code>INFO Discovering tests...\nINFO Discovered 1 test in 1 file\nINFO running  | test_parametrize::test_function [1, 4]\nINFO passed   | test_parametrize::test_function [1, 4]\nINFO running  | test_parametrize::test_function [2, 5]\nINFO passed   | test_parametrize::test_function [2, 5]\nINFO running  | test_parametrize::test_function [3, 6]\nINFO passed   | test_parametrize::test_function [3, 6]\nPassed tests: 3\nAll checks passed!\n</code></pre> <p>We can also mix fixtures and parametrize:</p> <pre><code>import karva\n\n@karva.fixture\ndef b() -&gt; int:\n    return 1\n\n@karva.tags.parametrize(\"a\", [1, 2])\ndef test_function(a: int, b: int):\n    assert a &gt; 0 and b &gt; 0\n</code></pre> <p>Then running <code>uv run karva test -v</code> will provide the following output:</p> <pre><code>INFO Discovering tests...\nINFO Discovered 1 test in 1 file\nINFO running  | test_parametrize::test_function [1, 1]\nINFO passed   | test_parametrize::test_function [1, 1]\nINFO running  | test_parametrize::test_function [2, 1]\nINFO passed   | test_parametrize::test_function [2, 1]\nPassed tests: 2\nAll checks passed!\n</code></pre> <p>We can also use multiple decorators:</p> <p>This will result in a sort of cartesian product of the parametrize values.</p> <pre><code>import karva\n\n@karva.tags.parametrize(\"a\", [1, 2])\n@karva.tags.parametrize(\"b\", [1, 2])\ndef test_function(a: int, b: int):\n    assert a &gt; 0 and b &gt; 0\n</code></pre> <p>Then running <code>uv run karva test -v</code> will provide the following output:</p> <pre><code>INFO Discovering tests...\nINFO Discovered 1 test in 1 file\nINFO running  | test_parametrize::test_function [1, 1]\nINFO passed   | test_parametrize::test_function [1, 1]\nINFO running  | test_parametrize::test_function [2, 1]\nINFO passed   | test_parametrize::test_function [2, 1]\nINFO running  | test_parametrize::test_function [1, 2]\nINFO passed   | test_parametrize::test_function [1, 2]\nINFO running  | test_parametrize::test_function [2, 2]\nINFO passed   | test_parametrize::test_function [2, 2]\nPassed tests: 4\nAll checks passed!\n</code></pre> <p>We can also still use pytest's <code>parametrize</code> decorator:</p> <pre><code>import pytest\n\n@pytest.mark.parametrize(\"a\", [1, 2])\ndef test_function(a: int):\n    assert a &gt; 0\n</code></pre> <p>Then running <code>uv run karva test -v</code> will provide the following output:</p> <pre><code>INFO Discovering tests...\nINFO Discovered 1 test in 1 file\nINFO running  | test_parametrize::test_function [1]\nINFO passed   | test_parametrize::test_function [1]\nINFO running  | test_parametrize::test_function [2]\nINFO passed   | test_parametrize::test_function [2]\nPassed tests: 2\nAll checks passed!\n</code></pre>"}]}